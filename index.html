<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>http/2</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<script type="text/template">
						# http/2

						### It's coming. Actually, it's here. Kind of.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						# Outline
						1. what's wrong with HTTP/1.1
						2. how we've overcome some of the problems
						3. a better HTTP?
					</script>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							## What's wrong with http/1.1?
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Protocol is massive and a bit dated
							* RFC for HTTP/0.9 (1991)
							* RFC for HTTP/1.0 (1995) 60 pages (added PUT, DELETE, LINK, UNLINK)
							* RFC for HTTP/1.1 (1997) grew to 176 pages
								* optional parts causing interoperability problems
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Inadequate use of TCP
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Size & Number of objects
							* size of data has risen (~ 2MB)
							* number of objects (~100)
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Latency
							* bandwidth increases
							* we haven't reduced latency much
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Head of line (HOL) blocking
							* responses have to be returned in the same order (FIFO)
							* HTTP pipelining is not turned on for most clients
							* large or slow response can still block others behind it
						</script>
					</section>

					<section data-background-color="#fff" data-markdown>
						<script type="text/template">
							![](images/pipelining2.png)
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							#### Max connections per hostname
							* HTTP/1.1 limits server requests to 2 (most browsers ignore and make 6-8 per host)
							* not unusual to use up to 100 connections for a single page
							* top 300K sites use 38 TCP connections
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							![](images/gophertiles.png)
							[http2.golang.org/gophertiles](http://http2.golang.org/gophertiles)
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							## Overcoming some of the problems
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Spriting
							* always transfer the full file
							* caching purges all at once vs. letting most common ones remain

							![](http://i.imgur.com/j8MGqYa.png)
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Inlining
							* size limits
							* can't be cached

							```
							<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAA
							          AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw=="
									 alt="1x1 transparent (GIF) pixel" />
							```
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Concatenation
							* small changes expire whole file from cache
							* serving _all_ our js/css on every page
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Sharding
							* new hostnames _{shard1, shardn}.example.com_
							* different hostnames mean extra DNS lookups, no cookies, a lot of smaller HTTP requests
						</script>
					</section>
				</section>

				<section data-markdown>
					<script type="text/template">
						## What would a better HTTP be?
						* less RTT sensitive
						* fix pipelining and HOL blocking
						* don't encourage increased number of TCP connections
						* keep existing URI formats (i.e. don't break the web)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## SPDY/2 (2012)
						* made by Google
						* open, but they pretty much wrote and implemented
						* SPDY/3 became draft 0 of HTTP/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## http/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## URI schemes
						* existing used for HTTP/1.x so we need a way to upgrade
						* HTTP/1.1 defined a way `Upgrade` header in response from server
						* cost of that is a round trip though
						* they added an extension to TLS called NPN, later replaced by APLN
							* basically client tells the server list of protocols in order of preference
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						```
							GET /page HTTP/1.1
							Host: server.example.com
							Connection: Upgrade, HTTP2-Settings
							Upgrade: h2c
							HTTP2-Settings: (SETTINGS payload)
						```

						#### server responds

						```
							HTTP/1.1 200 OK
							Content-length: 243
							Content-type: text/html

							(... HTTP/1.1 response ...)
						```

						#### or


						```
							HTTP/1.1 101 Switching Protocols
							Connection: Upgrade
							Upgrade: h2c

							(... HTTP/2 response ...)

						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Binary!
						* makes framing much easier - no optional white spaces!
						* TLS already diminishes the value of plain text
						* HTTP/2 sends binary frames
							* all have type, length, flags and a stream identifier
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](images/binary_framing.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## http/2 part/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Streams, Messages and Frames
						* *Stream* - a bi-directional flow of bytes withing a connection,
						which may carry one or more messages

						* *Message* - a sequence of frames that make up a logical HTTP message,
						such a as a request or a response

						* *Frame* - the smallest unit of communication that carries a type of data,
						such as headers or payload
					</script>
				</section>

				<section data-markdown data-background-color="#fff" data-background-image="images/steams_messages_frames.svg" data-background-size="900px">
					<script type="text/template"></script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Multiplexed streams
						* a single connection can have multiple concurrently open streams
						* either endpoint can interleave frames from muliple streams
						* the order of the frames however is significant as the
							recipient will process them in the order they are received
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](images/shared_connection.svg)
	 				</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Multiplexed streams
						* each stream has a priority
						* streams can be dependent on other streams
						* the dependency and priority allows clients to express how they would prefer to receive resources
							* html, css, javascript, fonts, images
						* priorites can be changed at runtime
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Headers
						* HTTP is stateless, so we send a lot of data in headers (cookies, etc.)
						* HTTP/2 doesn't change that but adds compression
						* HPACK - Header Compression for HTTP/2
						* all header field names are lowercase, and the request line is now split into individual
						`:method`, `:scheme`, `:host`, and `:path` pseudo-header fields.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## HPACK
						* header fields are encoded via a static Huffman code to reduce size
						* client and server maintain and update an indexed list of previously seen header fields,
							which allows more efficient encoding
					</script>
				</section>

				<section data-background-color="#fff" data-markdown data-background-image="images/header_compression.svg" data-background-size="800px">
					<script type="text/template"></script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Server push
						* client requests X server sents X, Y and Z
						* client puts Z in cache (client must explicitly allow that)
						![](images/server_push.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Server push
						* resources can be cached by the client
						* resources can be reused across different pages
						* resources can be prioritized by the server
						* resources can be declined by the client
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Considerations
						* connections will be much lengthier
						* client might be able to do everything over a single connection
						* load balancers need a way to pass on clients to another service
							* `alt-svc` header - client connects async to that and uses it if it works
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](images/aaron-paterson.jpg)

						> Uhm, hello Aaron? Can you make Rack compatible with HTTP/2?
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## HTTP/2 and Rails
						&#10003; request and response streaming should be the default

						&#10003; connections to backend servers should be persistent

						&#10060; communication should be message oriented

						&#10060;  communication should be bi-directional
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## How can we benefit from this now?
						* move assets to a HTTP/2 enabled CDN
						* use an HTTP/2 enabled proxy (nginx, h2o) infront of application servers
							* no server push or multiplexing
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Can I use?
						![](images/can_i_use.png)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Conclusion
						* reduces the number of round-trips
						* avoids HOL blocking with multiplexing
						* workarounds we do now won't be needed
							* concatenation, spriting, sharding will be detrimental
						* we'll need to develop for both HTTP/1.x and HTTP/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## References
						High Performance Browser Networking - Chapter 12

						https://hpbn.co/http2/

						HTTP/2 FAQ

						https://http2.github.io/faq/
					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
