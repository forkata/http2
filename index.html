<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>http/2</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<script type="text/template">
						# http/2

						### It's coming. Actually, it's here. Kind of.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						# Outline
						1. what's wrong with HTTP/1.1
						2. how we've overcome some of the problems
						3. a better HTTP?
					</script>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							## What's wrong with http/1.1?
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Protocol is massive and a bit dated
							* RFC for HTTP/0.9 (1991)
							* RFC for HTTP/1.0 (1995) 60 pages
							* RFC for HTTP/1.1 (1997) grew to 176 pages
								* optional parts causing interoperability problems
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Inadequate use of TCP
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Size & Number of objects
							* size of data has risen (~ 2MB)
							* number of objects (~100)
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Latency
							* bandwidth increases
							* we haven't reduced latency much
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Head of line (HOL) blocking
							* responses have to be returned in the same order (FIFO)
							* HTTP/1.1 limits server requests to 2 (limit removed, today 6-8 per host)
							* HTTP pipelining is not turned on for most clients
							* large or slow response can still block others behind it
						</script>
					</section>

					<section data-background-color="#fff" data-markdown>
						<script type="text/template">
							![](https://forkata.github.io/http2/images/pipelining2.png)
						</script>
					</section>

					<section data-markdown>
						<script type="text/template">
							![](https://forkata.github.io/http2/images/gophertiles.png)
							[http2.golang.org/gophertiles](http://http2.golang.org/gophertiles)
						</script>
					</section>
				</section>

				<section>
					<section data-markdown>
						<script type="text/template">
							## Overcoming some of the problems
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Spriting
							* always transfer the full file
							* caching purges all at once vs. letting most common ones remain

							![](http://i.imgur.com/j8MGqYa.png)
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Inlining
							* size limits
							* can't be cached

							```
							<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAA
							          AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw=="
									 alt="1x1 transparent (GIF) pixel" />
							```
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Concatenation
							* small changes expire whole file from cache
							* serving _all_ our js/css on every page
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							### Sharding
							* new hostnames _{shard1, shardn}.example.com_
							* not unusual to use up to 100 connections for a single page
							* top 300K sites use 38 TCP connections
							* different hostnames mean extra DNS lookups, no cookies, a lot of smaller HTTP requests
						</script>
					</section>
				</section>

				<section data-markdown>
					<script type="text/template">
						## What would a better HTTP be?
						* less RTT sensitive
						* fix pipelining and HOL blocking
						* don't encourage increased number of TCP connections
						* keep existing URI formats (i.e. don't break the web)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## SPDY/2 (2012)
						* made by Google
						* open, but they pretty much wrote and implemented
						* SPDY/3 became draft 0 of HTTP/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## http/2
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## URI schemes
						* existing used for HTTP/1.x so we need a way to upgrade
						* HTTP/1.1 defined a way 'Upgrade' header in response from server
						* cost of that is a round trip though
						* SPDY didn't accept that and since it was only over TLS,
							they added an extension to TLS called NPN (Next Protocol Negotiation), later replaced by APLN
							* client tells the server list of protocols in order of preference
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						```
							GET /page HTTP/1.1
							Host: server.example.com
							Connection: Upgrade, HTTP2-Settings
							Upgrade: h2c
							HTTP2-Settings: (SETTINGS payload)
						```

						```
							HTTP/1.1 200 OK
							Content-length: 243
							Content-type: text/html

							(... HTTP/1.1 response ...)
						```

						#### or


						```
							HTTP/1.1 101 Switching Protocols
							Connection: Upgrade
							Upgrade: h2c

							(... HTTP/2 response ...)

						```
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Binary!
						* makes framing much easier - no optional white spaces!
						* TLS already diminishes the value of plain text
						* HTTP/2 sends binary frames
							* all have type, length, flags and a stream identifier
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](https://forkata.github.io/http2/images/binary_framing.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Multiplexed streams
						* each frame sent over HTTP/2 is accociated with a 'stream'
						* a single connection can have multiple concurrently open streams
						* either endpoint can interleave frames from muliple streams
						* the order of the frames however is significant as the
							recipient will process them in the order they are received
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](https://forkata.github.io/http2/images/shared_connection.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Multiplexed streams
						* in HTTP/2 you will see 10-100 simultaneous streams and the cost of
							a new one is very low (all over single TCP connection)
						* each stream also has a priority
						* streams can be dependent on other streams
						* priorites can be changed at runtime
							* while scrolling down a page the browser can specify which images are more important
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Header compression
						* HTTP is stateless, so we send a lot of data in headers (cookies, etc.)
						* HTTP/2 doesn't change that but adds compression
						* HPACK - Header Compression for HTTP/2
						* all header field names are lowercase, and the request line is now split into individual
						_:method, :scheme, :authority, and :path_ pseudo-header fields.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						![](https://forkata.github.io/http2/images/header_compression.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Server push
						* client requests X server sents X and Z
						* client puts Z in cache (client must explicitly allow that)
						![](https://forkata.github.io/http2/images/server_push.svg)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Server push
						Some benefits over inlining resources
						*	cached by the client
						*	reused across different pages
						*	multiplexed alongside other resources
						*	prioritized by the server
						*	declined by the client
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Considerations
						* connections will be much lengthier
						* client might be able to do everything over a single connection
						* load balancers need a way to pass on clients to another service
							* alt-svc: header
							* client connects async to that and uses it if it works
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## How can we take advantage of this now?
						* move assets to a HTTP/2 enabled CDN
						* use an HTTP/2 enabled proxy (nginx, h2o)
							* no server push or multiplexing
						* as far as Rails goes
							* hope Rack implements HTTP/2
					</script>
				</section>


				<section data-markdown>
					<script type="text/template">
						## Can I use?
						![](https://forkata.github.io/http2/images/can_i_use.png)
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## Conclusion
						* reduces the number of round-trips
						* avoids HOL with multiplexing
						* a lot of the workarounds we do like spriting and inlining won't be needed
						* sharding will be detrimental
						* we'll need to develop for both HTTP/1.x and HTTP/2
						* mostly useful for browsers to start
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
						## References
						High Performance Browser Networking - Chapter 12

						https://hpbn.co/http2/

						HTTP/2 FAQ

						https://http2.github.io/faq/
					</script>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
